==============
plone.alterego
==============

Now you see it, it now you don't!

This package defines a dynamic module type that lets you create objects in the
dynamic module on demand.

Usage
-----

To use this package, you should:

 - Identify an appropriate parent module where the dynamic module will live.
  
 - Ensure that plone.alterego.dynamic.create() is called with this module and
   a dynamic module name. Typically, you'd do this in the parent module 
   itself, so that the dynamic module is instantiated as soon as the parent
   module is imported.
   
 - Register a named utility providing IDynamicObjectFactory. The name should
   be the same as the full dotted path to the dynamic module. This utility
   will be responsible for creating the objects that inhabit the dynamic
   module.

Dynamic interfaces
------------------

As an example of using plone.alterego, let's say we have a generic content 
class that should get a unique interface for each instance.

    >>> from zope import interface
    >>> class IContent(interface.Interface):
    ...     pass
    >>> class Content(object):
    ...     interface.implements(IContent)

    >>> c1 = Content()

To create the unique interface, we will use a dynamic module. There is a
helper method to make this easier. It takes a parent module and a name as
arguments:

    >>> from plone.alterego.dynamic import create
    >>> import plone.alterego.tests
    >>> dynamic_module = create(plone.alterego.tests, 'dynamic')

We can now import this module:

    >>> from plone.alterego.tests import dynamic
    >>> dynamic is dynamic_module
    True

The module doesn't have any items yet:

    >>> dynamic.IOne # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    AttributeError: 'DynamicModule' object has no attribute 'IOne'

To make objects on demand, we'll need to register a utility that can act
as a factory. This utility should have a name that corresponds to the full,
dotted name to the dynamic module. This way, we can have different factories
for different dynamic modules.

    >>> from plone.alterego.interfaces import IDynamicObjectFactory
    >>> from zope.interface.interface import InterfaceClass
    >>> class InterfaceOnDemand(object):
    ...     interface.implements(IDynamicObjectFactory)
    ...     
    ...     def __call__(self, name, module):
    ...         print "Creating", name, "in", module.__name__
    ...         return InterfaceClass(name, (interface.Interface,), __module__=module.__name__)

    >>> from zope.component import provideUtility
    >>> provideUtility(InterfaceOnDemand(), name='plone.alterego.tests.dynamic')

    >>> dynamic.IOne
    Creating IOne in plone.alterego.tests.dynamic
    <InterfaceClass plone.alterego.tests.dynamic.IOne>

Note that the factory is created once for each name only:

    >>> dynamic.IOne
    <InterfaceClass plone.alterego.tests.dynamic.IOne>

We could then create an on-demand interface easily:

    >>> interface.alsoProvides(c1, dynamic.ITwo)
    Creating ITwo in plone.alterego.tests.dynamic

    >>> list(interface.providedBy(c1).flattened()) # doctest: +NORMALIZE_WHITESPACE
    [<InterfaceClass plone.alterego.tests.dynamic.ITwo>, 
     <InterfaceClass __builtin__.IContent>,
     <InterfaceClass zope.interface.Interface>]

Crucially, so long as the factory always returns the same thing, the same
objects will be returned each time the module is accessed.

    >>> del dynamic
    >>> del dynamic_module

    >>> list(interface.providedBy(c1).flattened()) # doctest: +NORMALIZE_WHITESPACE
    [<InterfaceClass plone.alterego.tests.dynamic.ITwo>, 
     <InterfaceClass __builtin__.IContent>,
     <InterfaceClass zope.interface.Interface>]